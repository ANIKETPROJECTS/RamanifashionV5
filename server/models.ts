import mongoose, { Schema, Model } from 'mongoose';

// Product Schema
const productSchema = new Schema({
  name: { type: String, required: true },
  description: { type: String, required: true },
  price: { type: Number, required: true },
  originalPrice: { type: Number },
  images: [{ type: String }],
  category: { type: String, required: true },
  subcategory: { type: String },
  fabric: { type: String },
  color: { type: String },
  colorVariants: {
    type: [{
      color: { type: String, required: true },
      images: { 
        type: [{ type: String, required: true }],
        validate: {
          validator: function(v: string[]) {
            return v && v.length >= 1 && v.length <= 5 && v.every(url => url && url.trim().length > 0);
          },
          message: 'Each color variant must have between 1 and 5 non-empty image URLs'
        }
      },
      stockQuantity: { type: Number, default: 0 },
      inStock: { type: Boolean, default: true }
    }],
    validate: {
      validator: function(v: any[]) {
        return v && v.length >= 1;
      },
      message: 'Product must have at least one color variant'
    }
  },
  occasion: { type: String },
  pattern: { type: String },
  workType: { type: String },
  blousePiece: { type: Boolean, default: false },
  sareeLength: { type: String },
  inStock: { type: Boolean, default: true },
  stockQuantity: { type: Number, default: 0 },
  isNew: { type: Boolean, default: false },
  isBestseller: { type: Boolean, default: false },
  isTrending: { type: Boolean, default: false },
  onSale: { type: Boolean, default: false },
  rating: { type: Number, default: 0 },
  reviewCount: { type: Number, default: 0 },
  specifications: {
    fabricComposition: String,
    dimensions: String,
    weight: String,
    careInstructions: String,
    countryOfOrigin: String,
  },
  createdAt: { type: Date, default: Date.now },
  updatedAt: { type: Date, default: Date.now },
});

productSchema.index({ name: 'text', description: 'text' });

// User Schema (for Admin)
const userSchema = new Schema({
  name: { type: String, required: true },
  email: { type: String, required: true, unique: true },
  password: { type: String, required: true },
  phone: { type: String, required: true },
  phoneVerified: { type: Boolean, default: false },
  role: { type: String, default: 'admin' },
  createdAt: { type: Date, default: Date.now },
});

// Customer Schema (for phone-based OTP login)
const customerSchema = new Schema({
  phone: { type: String, required: true, unique: true },
  name: { type: String },
  email: { type: String },
  dob: { type: Date },
  address: {
    street: String,
    city: String,
    state: String,
    pincode: String,
    landmark: String,
  },
  phoneVerified: { type: Boolean, default: false },
  notifyUpdates: { type: Boolean, default: false },
  lastLogin: { type: Date },
  wishlist: [{
    productId: { type: Schema.Types.ObjectId, ref: 'Product' },
    addedAt: { type: Date, default: Date.now },
  }],
  cart: [{
    productId: { type: Schema.Types.ObjectId, ref: 'Product' },
    quantity: { type: Number, default: 1 },
    addedAt: { type: Date, default: Date.now },
  }],
  orders: [{
    orderId: { type: Schema.Types.ObjectId, ref: 'Order' },
    orderNumber: String,
    total: Number,
    status: String,
    createdAt: { type: Date, default: Date.now },
  }],
  createdAt: { type: Date, default: Date.now },
  updatedAt: { type: Date, default: Date.now },
});

// OTP Schema for temporary storage (dummy implementation)
const otpSchema = new Schema({
  phone: { type: String, required: true },
  otp: { type: String, required: true },
  verified: { type: Boolean, default: false },
  expiresAt: { type: Date, required: true },
  createdAt: { type: Date, default: Date.now },
});

// Address Schema
const addressSchema = new Schema({
  userId: { type: Schema.Types.ObjectId, ref: 'Customer', required: true },
  fullName: { type: String, required: true },
  phone: { type: String, required: true },
  pincode: { type: String, required: true },
  address: { type: String, required: true },
  locality: { type: String, required: true },
  city: { type: String, required: true },
  state: { type: String, required: true },
  landmark: { type: String },
  addressType: { type: String, enum: ['home', 'office'], default: 'home' },
  isDefault: { type: Boolean, default: false },
});

// Cart Schema
const cartSchema = new Schema({
  userId: { type: Schema.Types.ObjectId, ref: 'Customer', required: true },
  items: [{
    productId: { type: Schema.Types.ObjectId, ref: 'Product', required: true },
    quantity: { type: Number, required: true, default: 1 },
    selectedColor: { type: String },
    addedAt: { type: Date, default: Date.now },
  }],
  updatedAt: { type: Date, default: Date.now },
});

// Wishlist Schema
const wishlistSchema = new Schema({
  userId: { type: Schema.Types.ObjectId, ref: 'Customer', required: true },
  products: [{ type: Schema.Types.ObjectId, ref: 'Product' }],
  updatedAt: { type: Date, default: Date.now },
});

// Order Schema
const orderSchema = new Schema({
  userId: { type: Schema.Types.ObjectId, ref: 'Customer', required: true },
  orderNumber: { type: String, required: true, unique: true },
  items: [{
    productId: { type: Schema.Types.ObjectId, ref: 'Product', required: true },
    name: { type: String, required: true },
    price: { type: Number, required: true },
    quantity: { type: Number, required: true },
    image: { type: String },
  }],
  shippingAddress: {
    fullName: String,
    phone: String,
    address: String,
    locality: String,
    city: String,
    state: String,
    pincode: String,
    landmark: String,
  },
  subtotal: { type: Number, required: true },
  shippingCharges: { type: Number, default: 0 },
  tax: { type: Number, default: 0 },
  discount: { type: Number, default: 0 },
  total: { type: Number, required: true },
  paymentMethod: { type: String, required: true },
  paymentStatus: { type: String, enum: ['pending', 'paid', 'failed'], default: 'pending' },
  orderStatus: { type: String, enum: ['pending', 'approved', 'processing', 'shipped', 'delivered', 'cancelled'], default: 'pending' },
  approved: { type: Boolean, default: false },
  approvedBy: { type: String },
  approvedAt: { type: Date },
  phonePeTransactionId: { type: String },
  phonePeMerchantOrderId: { type: String },
  phonePeOrderId: { type: String },
  phonePePaymentState: { type: String },
  phonePePaymentDetails: { type: Schema.Types.Mixed },
  createdAt: { type: Date, default: Date.now },
  updatedAt: { type: Date, default: Date.now },
});

// Contact Submission Schema
const contactSubmissionSchema = new Schema({
  name: { type: String, required: true },
  mobile: { type: String, required: true },
  email: { type: String, required: true },
  subject: { type: String, required: true },
  category: { type: String, required: true },
  message: { type: String },
  createdAt: { type: Date, default: Date.now },
});

// Sync helper functions to keep Customer embedded arrays in sync with authoritative collections
async function syncCustomerCart(customerId: any) {
  try {
    const CustomerModel = mongoose.models.Customer || mongoose.model('Customer', customerSchema);
    const CartModel = mongoose.models.Cart || mongoose.model('Cart', cartSchema);
    
    const cart = await CartModel.findOne({ userId: customerId });
    const cartItems = cart?.items.map((item: any) => ({
      productId: item.productId,
      quantity: item.quantity,
      selectedColor: item.selectedColor,
      addedAt: item.addedAt
    })) || [];
    
    await CustomerModel.findByIdAndUpdate(customerId, {
      cart: cartItems,
      updatedAt: new Date()
    });
  } catch (error) {
    console.error('Error syncing customer cart:', error);
  }
}

async function syncCustomerWishlist(customerId: any) {
  try {
    const CustomerModel = mongoose.models.Customer || mongoose.model('Customer', customerSchema);
    const WishlistModel = mongoose.models.Wishlist || mongoose.model('Wishlist', wishlistSchema);
    
    const wishlist = await WishlistModel.findOne({ userId: customerId });
    const wishlistItems = wishlist?.products.map((productId: any) => ({
      productId,
      addedAt: wishlist.updatedAt || new Date()
    })) || [];
    
    await CustomerModel.findByIdAndUpdate(customerId, {
      wishlist: wishlistItems,
      updatedAt: new Date()
    });
  } catch (error) {
    console.error('Error syncing customer wishlist:', error);
  }
}

async function syncCustomerOrders(customerId: any) {
  try {
    const CustomerModel = mongoose.models.Customer || mongoose.model('Customer', customerSchema);
    const OrderModel = mongoose.models.Order || mongoose.model('Order', orderSchema);
    
    const orders = await OrderModel.find({ userId: customerId }).sort({ createdAt: -1 }).limit(20);
    const orderItems = orders.map((order: any) => ({
      orderId: order._id,
      orderNumber: order.orderNumber,
      total: order.total,
      status: order.orderStatus,
      createdAt: order.createdAt
    }));
    
    await CustomerModel.findByIdAndUpdate(customerId, {
      orders: orderItems,
      updatedAt: new Date()
    });
  } catch (error) {
    console.error('Error syncing customer orders:', error);
  }
}

// Add Mongoose middleware hooks to auto-sync embedded customer arrays

// Cart hooks
cartSchema.post('save', async function(doc) {
  if (doc.userId) {
    await syncCustomerCart(doc.userId);
  }
});

cartSchema.post('findOneAndUpdate', async function(doc) {
  if (doc?.userId) {
    await syncCustomerCart(doc.userId);
  }
});

cartSchema.post('findOneAndDelete', async function(doc) {
  if (doc?.userId) {
    await syncCustomerCart(doc.userId);
  }
});

// Wishlist hooks
wishlistSchema.post('save', async function(doc) {
  if (doc.userId) {
    await syncCustomerWishlist(doc.userId);
  }
});

wishlistSchema.post('findOneAndUpdate', async function(doc) {
  if (doc?.userId) {
    await syncCustomerWishlist(doc.userId);
  }
});

wishlistSchema.post('findOneAndDelete', async function(doc) {
  if (doc?.userId) {
    await syncCustomerWishlist(doc.userId);
  }
});

// Order hooks
orderSchema.post('save', async function(doc) {
  if (doc.userId) {
    await syncCustomerOrders(doc.userId);
  }
});

orderSchema.post('findOneAndUpdate', async function(doc) {
  if (doc?.userId) {
    await syncCustomerOrders(doc.userId);
  }
});

orderSchema.post('findOneAndDelete', async function(doc) {
  if (doc?.userId) {
    await syncCustomerOrders(doc.userId);
  }
});

orderSchema.post('deleteMany', async function() {
  // For bulk deletes, we need to sync all affected customers
  // This is a catch-all to ensure consistency
  const query = this.getFilter();
  if (query.userId) {
    await syncCustomerOrders(query.userId);
  }
});

// Export models
export const Product = mongoose.models.Product || mongoose.model('Product', productSchema);
export const User = mongoose.models.User || mongoose.model('User', userSchema);
export const Customer = mongoose.models.Customer || mongoose.model('Customer', customerSchema);
export const Address = mongoose.models.Address || mongoose.model('Address', addressSchema);
export const Cart = mongoose.models.Cart || mongoose.model('Cart', cartSchema);
export const Wishlist = mongoose.models.Wishlist || mongoose.model('Wishlist', wishlistSchema);
export const Order = mongoose.models.Order || mongoose.model('Order', orderSchema);
export const ContactSubmission = mongoose.models.ContactSubmission || mongoose.model('ContactSubmission', contactSubmissionSchema);
export const OTP = mongoose.models.OTP || mongoose.model('OTP', otpSchema);
